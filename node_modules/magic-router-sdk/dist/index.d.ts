import { Connection, Transaction, ConfirmOptions, TransactionSignature, Signer, BlockhashWithExpiryBlockHeight, SendOptions, PublicKey, TransactionConfirmationStrategy, RpcResponseAndContext, SignatureResult, Commitment, SignatureStatusConfig, SignatureStatus } from "@solana/web3.js";
/**
 * Get all writable accounts from a transaction.
 */
export declare function getWritableAccounts(transaction: Transaction): string[];
/**
 * Get the closest validator's public key from the router connection.
 */
export declare function getClosestValidator(routerConnection: Connection): Promise<PublicKey>;
/**
 * Get delegation status for a given account from the router.
 */
export declare function getDelegationStatus(connection: Connection, account: PublicKey | string): Promise<{
    isDelegated: boolean;
}>;
/**
 * Get the latest blockhash for a transaction based on writable accounts.
 */
export declare function getLatestBlockhashForMagicTransaction(connection: Connection, transaction: Transaction, options?: ConfirmOptions): Promise<BlockhashWithExpiryBlockHeight>;
/**
 * Prepare a transaction for sending by setting the recent blockhash.
 */
export declare function prepareMagicTransaction(connection: Connection, transaction: Transaction, options?: ConfirmOptions): Promise<Transaction>;
/**
 * Send a transaction, returning the signature of the transaction.
 * This function is modified to handle the magic transaction sending strategy by getting the latest blockhash based on writable accounts.
 */
export declare function sendMagicTransaction(connection: Connection, transaction: Transaction, signersOrOptions?: Array<Signer> | SendOptions, options?: SendOptions): Promise<TransactionSignature>;
/**
 * Confirm a transaction, returning the status of the transaction.
 * This function is modified to handle the magic transaction confirmation strategy.
 * ONLY supports polling for now.
 */
export declare function confirmMagicTransaction(connection: Connection, strategy: TransactionConfirmationStrategy | string, commitment?: Commitment): Promise<RpcResponseAndContext<SignatureResult>>;
/**
 * Send and confirm a transaction, returning the signature of the transaction.
 * ONLY supports polling for now.
 */
export declare function sendAndConfirmMagicTransaction(connection: Connection, transaction: Transaction, signers: Array<Signer>, options?: ConfirmOptions & Readonly<{
    abortSignal?: AbortSignal;
}>): Promise<TransactionSignature>;
/**
 * Poll the current status of a signature
 */
export declare function pollSignatureStatus(getSignatureStatus: (connection: Connection, signature: TransactionSignature, config?: SignatureStatusConfig) => Promise<RpcResponseAndContext<SignatureStatus | null>>, connection: Connection, signature: string, { intervalMs, timeoutMs, commitment, abortSignal, }?: {
    intervalMs?: number;
    timeoutMs?: number;
    commitment?: Commitment;
    abortSignal?: AbortSignal;
}): Promise<RpcResponseAndContext<SignatureResult>>;
/**
 * Get Commitment Confirmation
 */
export declare function GetCommitmentSignature(transactionSignature: TransactionSignature, transaction: Transaction, ephemeralConnection: Connection): Promise<TransactionSignature>;
